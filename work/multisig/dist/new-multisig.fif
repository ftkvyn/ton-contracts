"Asm.fif" include
// automatically generated from `./lib/stdlib.fc` `./src/multisig.fc` 
PROGRAM{
  DECLPROC recv_internal
  DECLPROC save_internal_data
  DECLPROC load_internal_data
  DECLPROC garbage_collect
  DECLPROC execute_order
  DECLPROC process_message
  DECLPROC recv_external
  85143 DECLMETHOD seqno
  DECLPROC load_order_by_condition
  DECLPROC get_key_num
  103571 DECLMETHOD pending_orders
  DECLPROC is_signed_orders
  122190 DECLMETHOD signed_orders
  121650 DECLMETHOD not_signed_orders
  recv_internal PROC:<{
    DROP
  }>
  save_internal_data PROC:<{
    NEWC
    s1 s5 XCHG
    8 STU
    s1 s3 XCHG
    8 STU
    32 STU
    STDICT
    STDICT
    ENDC
    c4 POP
  }>
  load_internal_data PROC:<{
    c4 PUSH
    CTOS
    8 LDU
    8 LDU
    32 LDU
    LDREF
    LDREF
    DROP
  }>
  garbage_collect PROC:<{
    1 PUSHINT
    NOW
    s3 PUSH
    REPEAT:<{
      32 PUSHINT
      s2 PUSH
      SWAP
      s4 PUSH
      SWAP
      DICTUGET
      NULLSWAPIFNOT
      IF:<{
        1 LDU
        32 LDU
        DROP
        s3 PUSH
        s6 PUSH
        LESS
        SWAP
        s0 s2 XCHG
        AND
        SWAP
        s2 PUSH
        LESS
        OR
        IF:<{
          32 PUSHINT
          s2 PUSH
          s0 s2 XCHG
          s1 s4 XCHG
          s0 s4 XCHG
          DICTUDELGET
          NULLSWAPIFNOT
          DROP
          DROP
        }>ELSE<{
          s0 s2 XCHG
        }>
      }>ELSE<{
        s1 s3 XCHG
        DROP
      }>
      SWAP
      INC
      s1 s2 XCHG
      SWAP
    }>
    DROP
    DROP
    DROP
    DROP
  }>
  execute_order PROC:<{
    ACCEPT
    8 LDU
    LDREF
    DROP
    SWAP
    SENDRAWMSG
  }>
  process_message PROC:<{
    s0 s5 XCHG
    LDREF
    OVER
    DICTEMPTY
    36 THROWIF
    LDREF
    DROP
    DUP
    HASHCU
    OVER
    CTOS
    32 LDU
    32 LDU
    DROP
    NOW
    OVER
    OVER
    LESS
    35 THROWIF
    s2 PUSH
    s8 PUSH
    GREATER
    34 THROWIF
    s2 PUSH
    1 LESSINT
    33 THROWIF
    32 PUSHINT
    s3 PUSH
    SWAP
    s12 PUSH
    SWAP
    DICTUGET
    NULLSWAPIFNOT
    s4 PUSH
    s10 PUSH
    LESS
    OVER
    0 EQINT
    AND
    40 THROWIF
    s4 PUSH
    s10 PUSH
    EQUAL
    IF:<{
      s0 s9 XCHG
      INC
    }>ELSE<{
      s0 s9 XCHG
    }>
    NEWDICT
    0 PUSHINT
    s11 PUSH
    IF:<{
      DROP
      DROP
      SWAP
      1 LDU
      32 LDU
      s0 s2 XCHG
      37 THROWIF
      SWAP
      s0 s3 XCHG
      LESS
      38 THROWIF
      SWAP
      8 LDU
      LDREF
      LDREF
      DROP
      HASHCU
      s6 PUSH
      EQUAL
      41 THROWIFNOT
    }>ELSE<{
      s2 s4 XCHG
      s0 s3 XCHG
      s1 s2 XCHG
      DROP
      DROP
    }>
    1 PUSHINT
    s12 PUSH
    REPEAT:<{
      8 PUSHINT
      OVER
      SWAP
      s10 PUSH
      SWAP
      DICTUGET
      NULLSWAPIFNOT
      IF:<{
        8 PUSHINT
        s2 PUSH
        SWAP
        s4 PUSH
        SWAP
        DICTUGET
        NULLSWAPIFNOT
        SWAP
        1 LDU
        DROP
        SWAP
        AND
        IFNOT:<{
          9 PUSHPOW2
          LDSLICEX
          DROP
          8 PUSHINT
          s2 PUSH
          SWAP
          s12 PUSH
          SWAP
          DICTUGET
          NULLSWAPIFNOT
          DROP
          256 LDU
          DROP
          s8 PUSH
          s0 s2 XCHG
          SWAP
          CHKSIGNU
          IF:<{
            s0 s2 XCHG
            INC
            1 PUSHINT
            NEWC
            -1 PUSHINT
            STUX
            8 PUSHINT
            s1 s2 XCHG
            s4 PUSH
            s0 s2 XCHG
            s1 s4 XCHG
            s0 s4 XCHG
            DICTUSETB
            OVER
            s12 PUSH
            EQUAL
            IFJMP:<{
              DROP
              DROP
              DROP
              NIP
              s2 POP
              s2 POP
              s2 POP
              s0 s3 XCHG
              IF:<{
                32 PUSHINT
                s3 PUSH
                s0 s2 XCHG
                s1 s7 XCHG
                s0 s7 XCHG
                DICTUDELGET
                NULLSWAPIFNOT
                DROP
                DROP
              }>ELSE<{
                s0 s5 XCHG
              }>
              1 PUSHINT
              NEWC
              -1 PUSHINT
              STUX
              32 PUSHINT
              s1 s3 XCHG
              s2 s4 XCHG
              s1 s4 XCHG
              DICTUSETB
              s3 s4 XCHG
              s2 s3 XCHG
              save_internal_data CALLDICT
              -1 PUSHINT
            }>
          }>ELSE<{
            s0 s2 XCHG
            SWAP
          }>
        }>ELSE<{
          s1 s3 XCHG
          s1 s2 XCHG
          DROP
        }>
      }>ELSE<{
        s1 s3 XCHG
        s1 s2 XCHG
        DROP
      }>
      s1 s2 XCHG
      SWAP
    }>
    DROP
    s5 POP
    s6 POP
    s0 s7 XCHG
    IF:<{
      32 PUSHINT
      s2 PUSH
      s0 s2 XCHG
      s1 s11 XCHG
      s0 s11 XCHG
      DICTUDELGET
      NULLSWAPIFNOT
      DROP
      DROP
    }>ELSE<{
      s0 s9 XCHG
    }>
    ACCEPT
    1 PUSHINT
    NEWC
    -1 PUSHINT
    STUX
    s1 s10 XCHG
    32 STU
    s1 s4 XCHG
    8 STU
    STDICT
    STREF
    32 PUSHINT
    s1 s3 XCHG
    s1 s7 XCHG
    DICTUSETB
    s3 s4 XCHG
    s2 s3 XCHG
    s1 s2 XCHG
    save_internal_data CALLDICT
    -1 PUSHINT
  }>
  recv_external PROC:<{
    load_internal_data CALLDICT
    s2 PUSH
    0 EQINT
    IFNOTJMP:<{
      process_message CALLDICT
    }>
    s2 POP
    s4 POP
    ACCEPT
    1 PUSHINT
    s3 s4 XCHG
    s2 s3 XCHG
    s0 s2 XCHG
    SWAP
    save_internal_data CALLDICT
  }>
  seqno PROC:<{
    c4 PUSH
    CTOS
    8 LDU
    NIP
    8 LDU
    NIP
    32 LDU
    DROP
  }>
  load_order_by_condition PROC:<{
    load_internal_data CALLDICT
    NIP
    s2 POP
    s2 POP
    PUSHNULL
    1 PUSHINT
    NOW
    s4 PUSH
    REPEAT:<{
      32 PUSHINT
      s2 PUSH
      SWAP
      s5 PUSH
      SWAP
      DICTUGET
      NULLSWAPIFNOT
      IF:<{
        1 LDU
        32 LDU
        8 LDU
        NIP
        LDREF
        LDREF
        DROP
        s5 PUSH
        s9 PUSH
        LESS
        SWAP
        s0 s4 XCHG
        AND
        s0 s2 XCHG
        s4 PUSH
        LESS
        s1 s2 XCHG
        OR
        IFNOT:<{
          s8 PUSH
          -1 EQINT
          IF:<{
            DROP
            SWAP
            s0 s3 XCHG
            CONS
          }>ELSE<{
            8 PUSHINT
            s9 PUSH
            s0 s2 XCHG
            SWAP
            DICTUGET
            NULLSWAPIFNOT
            DROP
            1 LDU
            DROP
            s7 PUSH
            SWAP
            EQUAL
            IF:<{
              SWAP
              s0 s3 XCHG
              CONS
            }>ELSE<{
              s1 s3 XCHG
              DROP
            }>
          }>
        }>ELSE<{
          s2 s4 XCHG
          DROP
          DROP
        }>
      }>ELSE<{
        s1 s3 XCHG
        DROP
      }>
      SWAP
      INC
      s1 s2 XCHG
      SWAP
    }>
    DROP
    DROP
    NIP
    NIP
    NIP
    NIP
  }>
  get_key_num PROC:<{
    load_internal_data CALLDICT
    DROP
    NIP
    NIP
    0 PUSHINT
    s0 s2 XCHG
    REPEAT:<{
      8 PUSHINT
      s2 PUSH
      SWAP
      s2 PUSH
      SWAP
      DICTUGET
      NULLSWAPIFNOT
      DROP
      256 LDU
      DROP
      s3 PUSH
      EQUAL
      IFJMP:<{
        DROP
        NIP
      }>
    }>
    DROP
    DROP
    DROP
    -1 PUSHINT
  }>
  pending_orders PROC:<{
    0 PUSHINT
    DUP
    load_order_by_condition CALLDICT
  }>
  is_signed_orders PROC:<{
    SWAP
    get_key_num CALLDICT
    SWAP
    load_order_by_condition CALLDICT
  }>
  signed_orders PROC:<{
    -1 PUSHINT
    is_signed_orders CALLDICT
  }>
  not_signed_orders PROC:<{
    0 PUSHINT
    is_signed_orders CALLDICT
  }>
}END>c
constant code

"TonUtil.fif" include

{ ."usage: " @' $0 type ." <workchain-id> <n> <k> [<filename-base>]" cr
  ."Creates a new multisign wallet in specified workchain, with private key saved to or loaded from <filename-base>.pk" cr
  ."('new-multi-wallet.pk' by default)" cr
  ."  n is the number of keys" cr
  ."  k is the number of signs needed for a message" cr
  1 halt
} : usage
$# dup 3 < swap 4 > or ' usage if

$1 parse-workchain-id =: wc    // set workchain id from command line argument
$2 parse-int =: total-keys
$3 parse-int =: sign-keys
def? $4 { @' $4 } { "new-multi-wallet" } cond constant file-base

0 constant seq_no

."Creating new wallet in workchain " wc . cr

dictnew constant keys-dict

keys-dict
1
{
    dup
    "key_" swap (.) +".pk" $+
    load-generate-keypair
    drop // private key
    <b swap B, b> <s .s
    over 100 + 3 roll 8 udict!+ 0= abort"key already added"
    swap
     1 +
} total-keys times
."done generating/loading keys" cr

drop // counter
constant keys-dict

<b b>
constant transactions-dict

<b total-keys 8 u, 
   sign-keys 8 u,
   seq_no 32 u,
   keys-dict ref,
   transactions-dict ref, // transactions
b>  constant storage

."Storage: " cr storage <s csr. cr

<b b{0011} s, code ref, storage ref, null dict, b> constant state_init // create StateInit
state_init
dup ."StateInit: " <s csr. cr
dup hash wc swap 2dup 2constant wallet_addr
."new wallet address = " 2dup .addr cr
2dup file-base +".addr" save-address-verbose
."Non-bounceable address (for init): " 2dup 7 .Addr cr
."Bounceable address (for later access): " 6 .Addr cr
<b b{1000100} s, wallet_addr addr, b{000010} s, state_init <s s, b{0} s, transactions-dict ref, b>
dup ."External message for initialization is " <s csr. cr
2 boc+>B dup Bx. cr
file-base +"-query.boc" tuck B>file
."(Saved wallet creating query to file " type .")" cr
