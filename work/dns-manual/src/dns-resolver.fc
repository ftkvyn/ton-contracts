() recv_internal(slice in_msg) impure {
  ;; do nothing for internal messages
}

_ recv_external(slice in_msg) impure {
    var signature = in_msg~load_bits(512);
    cell msg_body = in_msg~load_ref();

    slice data_slice = begin_parse(get_data());
    int stored_seqno = data_slice~load_uint(32);
    int public_key = data_slice~load_uint(256);
    
    throw_unless(34, check_signature(cell_hash(msg_body), signature, public_key));
    accept_message();

    slice msg_slice = msg_body.begin_parse();
    int mode = msg_slice~load_uint(8);
    if(mode == 7) {
        ;; Initialization of the contract
        throw_if(32, stored_seqno);
        ;; populating new dict with some trash because empty dict doesn't work well.
        cell new_dns_dict = new_dict();
        cell new_cat_dict = new_dict();
        new_cat_dict~udict_set_builder(16, 0, begin_cell().store_uint(1,1));
        new_dns_dict~udict_set_builder(256, 0, begin_cell().store_dict(new_cat_dict));
        set_data(begin_cell()
            .store_uint(1, 32)
            .store_uint(public_key, 256)
            ;; ToDo: divide into several dicts with different key length - 32, 64, 256 bits
            .store_dict(new_dns_dict) ;; DNS entries dict
            .end_cell());
        return -1;
    }

    cell dns_dict = data_slice~load_ref();

    if (mode == 3) {
        ;; Updating stored public_key
        int new_public_key = msg_slice~load_uint(256);
        set_data(begin_cell()
            .store_uint(stored_seqno, 32)
            .store_uint(new_public_key, 256)
            .store_dict(dns_dict)
            .end_cell());
        return -1;
    }

    if (mode == 1) {
        ;; New dns entry
        int msg_seqno = msg_slice~load_uint(32);

        ;; ToDo: implement dns update

        return -1;
    }
    
    
    throw_if(404, -1); ;; Unknown message mode
    return 404;
}

(int cell) resolve_single_entry(int str_int, int category) {
    (slice categories_slice, int is_found) = dns_dict.udict_get?(256, str_int);
    ifnot(is_found) {
        return (0, new_dict());
    }
    if (category == 0) {
        return (len + 8, begin_cell().store_slice(categories_slice).end_cell());
    }
    (slice value_slice, int is_found) = categories_slice~load_dict().idict_get?(16, category);
    ifnot(is_found) {
        return (0, new_dict());
    }

    return (len + 8, begin_cell().store_slice(value_slice).end_cell());
}

(int cell) dnsresolve(slice dns_str, int category) method_id {

    slice data_slice = get_data().begin_parse();
    int stored_seqno = data_slice~load_uint(32);
    int public_key = data_slice~load_uint(256);
    cell dns_dict = data_slice~load_dict();

    int len = dns_str.slice_bits();
    len -= 8;
    int str_int = dns_str~load_uint(len);
    int following_zero = dns_str~load_uint(8);    
    dump_stack();
    throw_if(55, following_zero); ;;wrong format

    ;; ToDo: look for other zero-byes and handle it.
    
    return resolve_single_entry(str_int, category);
}